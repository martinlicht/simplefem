  
  
  
  **** TODO ***
  
  Question:
    - how to manage unit test for a software library?
    - how to manage makefiles? what dependencies to make explicit?
  
  Documentation:
    Sphinx seems viable 
    http://www.sphinx-doc.org/en/stable/
    Videos at 
    https://en.wikipedia.org/wiki/Sphinx_(documentation_generator)
    Could be used for personal websites 
    
  todo-listen in jedem modul:
    - liste der klassen und standard punkte 
      - fertig
      - check
      - unittest 
    - liste der methodenpakete und standard punkte 
      - unittest 
    - Feature liste welche erwünscht ist: near/far future 
    
  unit test layout:
    logstream that is reference to std::cout 
    TEST_DECL_MODULE( str );
    TEST_DECL_CLASS ( str );
    TEST_DECL_BASIC (     );
    TEST_DECL_TOPIC ( str );
    TEST_ANNOUNCE();
    
    
    

  ************* General layout: 
  
  - Reduce dense matrix module to the core functions of dense matrices
  - Module for Matrix I/O 
  
  
  
  
  
  
  ************* Dense Matrix algorithms to implement:
  
  - Gerschgorin (row/column) circles, and maximal estimate 
    perhaps more estimators 
  
  - Diagonal solve 
  - Left triangular solve 
  - Right triangular solve 
  - Unit Left triangular solve 
  - Unit Right triangular solve 
  - (Averages between left and right triangular solves)
  
  - check whether diagonal 
  - check whether (unit) left/right triangular 
  
  - LU decomposition 
  - LU decomposition, row pivot
  - LU decomposition, column pivot 
  - LU decomposition, full pivot 
  
  - Cholesky 
  - Cholesky, pivot 
   
  - stabilized Gram-Schmidt 
  
  - QR decomposition 
  
  
  
  
  
  
  ************* SparseMatrix algorithms 
  
  - Gerschgorin rows 

  - Diagonal solve 
  - Left triangular solve 
  - Right triangular solve 
  - Unit Left triangular solve 
  - Unit Right triangular solve 
  
  - check whether diagonal 
  - check whether (unit) left/right triangular 
  
  - Input/Output routines 
  
  
  
  
  
  
  ************* Iterative solvers to implement: 
  
  - Richardson with relaxation parameter 
  - Richardson with preconditioner 
  
  - Jacobi preconditioner
  - different scaling preconditioners 
  - Gauss Seidel preconditioner
  - SOR preconditioner
  - SSOR preconditioner
  
  - Advanced:
    block diagonal preconditioner (block size and layout variable)
    block gauss seidel preconditioner 
    adjustable gauss seidel 
  
  - Gradient energy descent 
  - Gradient residual descent 
   
  - Symmetric Lanczos minimum residual method 
  - Conjugate Gradient 
  - Conjugate Residual 
  
  - Poly preconditioner varianten einbauen 
  
  (Arnoldi, GMRES, etc...)
  
  
  
  
  ************* FE Matrices: 
  - Static condensation kann einfacher implementiert werden, 
    falls die entsprechenden Freiheitsgrade schon vorher aussortiert werden. 
  
  
  
  ************* VTK Module
  - Implement a reader + writer class
    and classes for the different parts of a VTK-File
  - Read/Write VTK Headers
  - Read/Write data sets (derived from generic data set class)
  - Perhaps conversion between data set classes
  - Conversion between non-VTK related formats
  - Direct IO with mesh and algebra classes via specialized routines 
  
  Simple legacy format:
    http://www.vtk.org/wp-content/uploads/2015/04/file-formats.pdf
    Reading only ASCII
  
  
  ************* Mesh
  - Mesh
    - manifold 2D
    - manifold 3D
    - allgemeine manifold
    - allgemeines mesh
  - uniform refinement:
    zuerst verstehen, dann implementieren
  - Konstruktion der FE-Spaces so weit wie geht allgemein halten
  - bisection refinement:
    zuerst verstehen, dann implementieren
  - Ein eigenes Ausgabeformat ist notwendig
    Unterscheidung nach Spezialklassen
    I/O in andere Formate ist zweitrangig
  
  
  
  
  
  
  
  
  
  
